```{r}
pacman::p_load(tidyverse, jsonlite)
load("./r/dic/sim_dic.rda")
cores <- c(
  '#FED789FF',
  '#023743FF',
  '#72874EFF',
  '#476F84FF',
  '#A4BED5FF',
  '#453947FF'
)


dic_genero_idade <- sim_dic |>
  group_by(idade, genero) |>
  reframe(n = n()) |>
  pivot_wider(names_from = genero, values_from = n, values_fill = 0) |>
  select(-Outro) |>
  write_json('./fontes/dic_genero_idade.json')


dic_raca_cor_idade <- sim_dic |>
  group_by(idade, raca_cor) |>
  reframe(n = n()) |>
  pivot_wider(names_from = raca_cor, values_from = n, values_fill = 0) |>
  select(-SI) |>
  write_json('./fontes/dic_raca_cor_idade.json')



```




```{ojs}
//| echo: false
echarts = require("echarts@5")

// Ler dados do arquivo JSON (gênero x idade)
dic_genero_idade = FileAttachment("./fontes/dic_genero_idade.json").json();

// Filtrar dados para idades de 0 a 100
dados_filtrados_1 = dic_genero_idade.filter(d => d.idade >= 0 && d.idade <= 100)

chart_dic_genero_idade = {
  const chartDom = DOM.element('div', { 
    style: `
      width: 100%; 
      height: 60vw; 
      max-height: 400px; 
      min-height: 300px;
    ` 
  });

  // Aguarda o DOM estar renderizado usando requestAnimationFrame
  requestAnimationFrame(() => {
    // Inicializa o gráfico após o DOM estar pronto
    const myChart = echarts.init(chartDom);
    
    // Idades no eixo X
    const idades = dados_filtrados_1.map(d => d.idade);
    
    // Pega as chaves que representam gêneros (tudo exceto 'idade')
    const generos = Object.keys(dados_filtrados_1[0]).filter(k => k !== 'idade');
    
    // Quais séries marcar com "pico" (ajuste se tiver Outros, etc.)
    const generosParaMarcar = ['Fem', 'Masc'];
    
    const option = {
      title: { text: 'Distribuição por Gênero e Idade (0 a 100 anos)' },
      tooltip: { trigger: 'axis' },
      legend: { data: generos, bottom: 10 },
      grid: { left: '3%', right: '4%', bottom: '15%', containLabel: true },
      toolbox: { feature: { saveAsImage: {} } },
      xAxis: { type: 'category', boundaryGap: false, data: idades, name: 'Idade' },
      yAxis: { type: 'value', name: 'Quantidade' },
      animationDuration: 3000,
      animationEasing: 'cubicOut',
      series: generos.map(genero => ({
        name: genero,
        type: 'line',
        data: dados_filtrados_1.map(d => d[genero] ?? 0)
      }))
    };
    
    // Renderiza linhas primeiro
    myChart.setOption(option);
    
    // Depois adiciona os markPoints (picos)
    setTimeout(() => {
      const seriesComPicos = generos.map(genero => {
        const dadosSerie = dados_filtrados_1.map(d => d[genero] ?? 0);
        let markPoint = {};
        
        if (generosParaMarcar.includes(genero)) {
          const valorMax = Math.max(...dadosSerie);
          const idxMax = dadosSerie.indexOf(valorMax);
          const idadeMax = dados_filtrados_1[idxMax]?.idade;
          
          markPoint = {
            data: [{
              type: 'max',
              label: {
                show: true,
                position: 'top',
                formatter: `Pico ${genero}: ${idadeMax} anos`,
                backgroundColor: 'rgba(255, 255, 255, 0.9)',
                borderColor: '#333',
                borderWidth: 1,
                borderRadius: 4,
                padding: [6, 10],
                fontSize: 12,
                fontWeight: 'bold'
              },
              symbol: 'circle',
              symbolSize: 8
            }],
            animation: true,
            animationDuration: 800
          };
        }
        
        return {
          name: genero,
          type: 'line',
          data: dadosSerie,
          markPoint
        };
      });
      
      myChart.setOption({ series: seriesComPicos });
    }, 3100);

    // Event listener para redimensionamento
    const resizeHandler = () => {
      myChart.resize();
    };
    
    window.addEventListener('resize', resizeHandler);
    
    // Cleanup quando a célula for re-executada
    invalidation.then(() => {
      window.removeEventListener('resize', resizeHandler);
      myChart.dispose();
    });
  });

  return chartDom;
}
```

```{ojs}
//| echo: false
// Ler dados do arquivo JSON
dic_raca_cor_idade = FileAttachment("./fontes/dic_raca_cor_idade.json").json()

// Filtrar dados para idades de 0 a 100
dados_filtrados = dic_raca_cor_idade.filter(d => d.idade >= 0 && d.idade <= 100)

chart_raca_cor_idade = {
  const chartDom = DOM.element('div', { 
    style: `
      width: 100%; 
      height: 60vw; 
      max-height: 400px; 
      min-height: 300px;
    ` 
  });

  // Aguarda o DOM estar renderizado usando requestAnimationFrame
  requestAnimationFrame(() => {
    // Inicializa o gráfico após o DOM estar pronto
    const myChart = echarts.init(chartDom);
    
    // Extrair as idades para o eixo X (agora filtradas)
    const idades = dados_filtrados.map(d => d.idade);
    
    // Extrair as raças/cores (excluindo 'idade')
    const racas = Object.keys(dados_filtrados[0]).filter(key => key !== 'idade');
    
    // Encontrar os picos para Branca, Preta e Parda
    const racasParaMarcar = ['Branca', 'Preta', 'Parda'];
    
    const option = {
      title: {
        text: 'Distribuição por Raça/Cor e Idade (0 a 100 anos)'
      },
      tooltip: {
        trigger: 'axis'
      },
      legend: {
        data: racas,
        bottom: 10
      },
      grid: {
        left: '3%',
        right: '4%',
        bottom: '15%',
        containLabel: true
      },
      toolbox: {
        feature: {
          saveAsImage: {}
        }
      },
      xAxis: {
        type: 'category',
        boundaryGap: false,
        data: idades,
        name: 'Idade'
      },
      yAxis: {
        type: 'value',
        name: 'Quantidade'
      },
      // Configurações de animação
      animationDuration: 3000,
      animationEasing: 'cubicOut',
      series: racas.map(raca => {
        const dados = dados_filtrados.map(d => d[raca]);
        
        return {
          name: raca,
          type: 'line',
          data: dados
        };
      })
    };
    
    // Renderizar o gráfico inicialmente sem os markPoints
    myChart.setOption(option);
    
    // Adicionar markPoints após a animação terminar
    setTimeout(() => {
      const seriesWithMarkPoints = racas.map(raca => {
        const dados = dados_filtrados.map(d => d[raca]);
        
        // Se for uma das raças para marcar, adicionar markPoint
        let markPoint = {};
        if (racasParaMarcar.includes(raca)) {
          const valorMaximo = Math.max(...dados);
          const indiceMaximo = dados.indexOf(valorMaximo);
          const idadeMaxima = dados_filtrados[indiceMaximo].idade;
          
          markPoint = {
            data: [{
              type: 'max',
              label: {
                show: true,
                position: 'top',
                formatter: `Pico ${raca}: ${idadeMaxima} anos`,
                backgroundColor: 'rgba(255, 255, 255, 0.9)',
                borderColor: '#333',
                borderWidth: 1,
                borderRadius: 4,
                padding: [6, 10],
                fontSize: 12,
                fontWeight: 'bold'
              },
              symbol: 'circle',
              symbolSize: 8
            }],
            animation: true,
            animationDuration: 800
          };
        }
        
        return {
          name: raca,
          type: 'line',
          data: dados,
          markPoint: markPoint
        };
      });
      
      // Atualizar o gráfico com os markPoints
      myChart.setOption({
        series: seriesWithMarkPoints
      });
    }, 3100); // Esperar 3100ms (um pouco depois da animação das linhas)

    // Event listener para redimensionamento
    const resizeHandler = () => {
      myChart.resize();
    };
    
    window.addEventListener('resize', resizeHandler);
    
    // Cleanup quando a célula for re-executada
    invalidation.then(() => {
      window.removeEventListener('resize', resizeHandler);
      myChart.dispose();
    });
  });

  return chartDom;
}
```


```{ojs}
//| echo: false
// Ler dados do arquivo JSON (cada objeto deve ter a chave "ano" + colunas de raça/cor)
dic_raca_cor_ano = FileAttachment("./fontes/dic_raca_cor_ano.json").json()

// Ordenar por ano e garantir numérico
dados_ordenados = dic_raca_cor_ano
  .map(d => ({ ...d, ano: +d.ano }))
  .filter(d => !Number.isNaN(d.ano))
  .sort((a, b) => d3.ascending(a.ano, b.ano))

chart_ano = {
  const chartDom = DOM.element('div', { 
    style: `
      width: 100%; 
      height: 60vw; 
      max-height: 400px; 
      min-height: 300px;
    ` 
  });

  // Aguarda o DOM estar renderizado usando requestAnimationFrame
  requestAnimationFrame(() => {
    // Inicializa o gráfico após o DOM estar pronto
    const myChart = echarts.init(chartDom);
    
    // Eixo X com anos (ordenados)
    const anos = dados_ordenados.map(d => d.ano)
    
    // Descobrir as séries (todas as chaves exceto "ano")
    const racas = Object.keys(dados_ordenados[0] || {}).filter(k => k !== 'ano')
    
    // Raças que receberão markPoint no pico
    const racasParaMarcar = ['Branca', 'Preta', 'Parda']
    
    const option = {
      title: { text: 'Distribuição por Raça/Cor ao longo dos anos' },
      tooltip: { trigger: 'axis' },
      legend: { data: racas, bottom: 10 },
      grid: { left: '3%', right: '4%', bottom: '15%', containLabel: true },
      toolbox: { feature: { saveAsImage: {} } },
      xAxis: {
        type: 'category',
        boundaryGap: false,
        data: anos,
        name: 'Ano'
      },
      yAxis: { type: 'value', name: 'Quantidade' },
      // paleta base (sobrescrevemos por série logo abaixo)
      color: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'],
      animationDuration: 3000,
      animationEasing: 'cubicOut',
      series: racas.map((raca, index) => {
        const dados = dados_ordenados.map(d => +d[raca] || 0)
        const coresPorRaca = {
          Branca:   '#2E86AB',
          Parda:    '#A23B72',
          Preta:    '#F18F01',
          Amarela:  '#C73E1D',
          Indígena: '#592E83'
        }
        const cor = coresPorRaca[raca] || `hsl(${index * 72}, 70%, 50%)`
        return {
          name: raca,
          type: 'line',
          data: dados,
          itemStyle: { color: cor },
          lineStyle: { color: cor }
        }
      })
    }
    
    // Render inicial sem markPoints
    myChart.setOption(option)
    
    // Após a animação, adicionar markPoints nos picos das séries escolhidas
    setTimeout(() => {
      const seriesWithMarkPoints = racas.map((raca, index) => {
        const dados = dados_ordenados.map(d => +d[raca] || 0)
        const coresPorRaca = {
          Branca:   '#FED789',  // mantive sua paleta custom
          Parda:    '#72874E',
          Preta:    '#476F84',
          Amarela:  '#A4BED5',
          Indígena: '#453947'
        }
        const cor = coresPorRaca[raca] || `hsl(${index * 72}, 70%, 50%)`
        let markPoint = {}
        if (racasParaMarcar.includes(raca) && dados.length) {
          const valorMaximo = Math.max(...dados)
          const indiceMaximo = dados.indexOf(valorMaximo)
          const anoPico = anos[indiceMaximo]
          markPoint = {
            data: [{
              type: 'max',
              name: 'Pico',
              label: {
                show: false,
                position: 'top',
                formatter: `${raca} - pico: ${anoPico}`,
                backgroundColor: 'rgba(255, 255, 255, 0.9)',
                borderColor: cor,
                borderWidth: 1,
                borderRadius: 4,
                padding: [6, 10],
                fontSize: 12,
                fontWeight: 'bold'
              },
              symbol: 'circle',
              symbolSize: 8,
              itemStyle: { color: cor }
            }],
            animation: true,
            animationDuration: 800
          }
        }
        return {
          name: raca,
          type: 'line',
          data: dados,
          itemStyle: { color: cor },
          lineStyle: { color: cor },
          markPoint
        }
      })
      
      myChart.setOption({ series: seriesWithMarkPoints })
    }, 3100)

    // Event listener para redimensionamento
    const resizeHandler = () => {
      myChart.resize();
    };
    
    window.addEventListener('resize', resizeHandler);
    
    // Cleanup quando a célula for re-executada
    invalidation.then(() => {
      window.removeEventListener('resize', resizeHandler);
      myChart.dispose();
    });
  });

  return chartDom;
}
```



::: {.columns}


::: {.column width="100%"}
::: {.card}
###  Lista de DICs
I20 - Angina pectoris (dor torácica)  
I21 - Infarto agudo do miocárdio - Principal causa de mortalidade no Brasil  
I22 - Infarto do miocárdio recorrente  
I23 - Algumas complicações atuais subseqüentes ao infarto agudo do miocárdio  
I24 - Outras doenças isquêmicas agudas do coração  
I25 - Doença isquêmica crônica do coração  
:::
:::

:::
