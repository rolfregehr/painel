[
  {
    "objectID": "pneumonia.html",
    "href": "pneumonia.html",
    "title": "",
    "section": "",
    "text": "teste"
  },
  {
    "objectID": "dic_dev.html",
    "href": "dic_dev.html",
    "title": "",
    "section": "",
    "text": "echarts = require(\"echarts@5\")\n\n// Ler dados do arquivo JSON (gênero x idade)\ndic_genero_idade = FileAttachment(\"./fontes/dic_genero_idade.json\").json();\n\n// Filtrar dados para idades de 0 a 100\ndados_filtrados_1 = dic_genero_idade.filter(d =&gt; d.idade &gt;= 0 && d.idade &lt;= 100)\n\nchart_dic_genero_idade = {\n  const chartDom = DOM.element('div', { \n    style: `\n      width: 100%; \n      height: 60vw; \n      max-height: 400px; \n      min-height: 300px;\n    ` \n  });\n\n  // Aguarda o DOM estar renderizado usando requestAnimationFrame\n  requestAnimationFrame(() =&gt; {\n    // Inicializa o gráfico após o DOM estar pronto\n    const myChart = echarts.init(chartDom);\n    \n    // Idades no eixo X\n    const idades = dados_filtrados_1.map(d =&gt; d.idade);\n    \n    // Pega as chaves que representam gêneros (tudo exceto 'idade')\n    const generos = Object.keys(dados_filtrados_1[0]).filter(k =&gt; k !== 'idade');\n    \n    // Quais séries marcar com \"pico\" (ajuste se tiver Outros, etc.)\n    const generosParaMarcar = ['Fem', 'Masc'];\n    \n    const option = {\n      title: { text: 'Distribuição por Gênero e Idade (0 a 100 anos)' },\n      tooltip: { trigger: 'axis' },\n      legend: { data: generos, bottom: 10 },\n      grid: { left: '3%', right: '4%', bottom: '15%', containLabel: true },\n      toolbox: { feature: { saveAsImage: {} } },\n      xAxis: { type: 'category', boundaryGap: false, data: idades, name: 'Idade' },\n      yAxis: { type: 'value', name: 'Quantidade' },\n      animationDuration: 3000,\n      animationEasing: 'cubicOut',\n      series: generos.map(genero =&gt; ({\n        name: genero,\n        type: 'line',\n        data: dados_filtrados_1.map(d =&gt; d[genero] ?? 0)\n      }))\n    };\n    \n    // Renderiza linhas primeiro\n    myChart.setOption(option);\n    \n    // Depois adiciona os markPoints (picos)\n    setTimeout(() =&gt; {\n      const seriesComPicos = generos.map(genero =&gt; {\n        const dadosSerie = dados_filtrados_1.map(d =&gt; d[genero] ?? 0);\n        let markPoint = {};\n        \n        if (generosParaMarcar.includes(genero)) {\n          const valorMax = Math.max(...dadosSerie);\n          const idxMax = dadosSerie.indexOf(valorMax);\n          const idadeMax = dados_filtrados_1[idxMax]?.idade;\n          \n          markPoint = {\n            data: [{\n              type: 'max',\n              label: {\n                show: true,\n                position: 'top',\n                formatter: `Pico ${genero}: ${idadeMax} anos`,\n                backgroundColor: 'rgba(255, 255, 255, 0.9)',\n                borderColor: '#333',\n                borderWidth: 1,\n                borderRadius: 4,\n                padding: [6, 10],\n                fontSize: 12,\n                fontWeight: 'bold'\n              },\n              symbol: 'circle',\n              symbolSize: 8\n            }],\n            animation: true,\n            animationDuration: 800\n          };\n        }\n        \n        return {\n          name: genero,\n          type: 'line',\n          data: dadosSerie,\n          markPoint\n        };\n      });\n      \n      myChart.setOption({ series: seriesComPicos });\n    }, 3100);\n\n    // Event listener para redimensionamento\n    const resizeHandler = () =&gt; {\n      myChart.resize();\n    };\n    \n    window.addEventListener('resize', resizeHandler);\n    \n    // Cleanup quando a célula for re-executada\n    invalidation.then(() =&gt; {\n      window.removeEventListener('resize', resizeHandler);\n      myChart.dispose();\n    });\n  });\n\n  return chartDom;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndic_raca_cor_idade = FileAttachment(\"./fontes/dic_raca_cor_idade.json\").json()\n\n// Filtrar dados para idades de 0 a 100\ndados_filtrados = dic_raca_cor_idade.filter(d =&gt; d.idade &gt;= 0 && d.idade &lt;= 100)\n\nchart_raca_cor_idade = {\n  const chartDom = DOM.element('div', { \n    style: `\n      width: 100%; \n      height: 60vw; \n      max-height: 400px; \n      min-height: 300px;\n    ` \n  });\n\n  // Aguarda o DOM estar renderizado usando requestAnimationFrame\n  requestAnimationFrame(() =&gt; {\n    // Inicializa o gráfico após o DOM estar pronto\n    const myChart = echarts.init(chartDom);\n    \n    // Extrair as idades para o eixo X (agora filtradas)\n    const idades = dados_filtrados.map(d =&gt; d.idade);\n    \n    // Extrair as raças/cores (excluindo 'idade')\n    const racas = Object.keys(dados_filtrados[0]).filter(key =&gt; key !== 'idade');\n    \n    // Encontrar os picos para Branca, Preta e Parda\n    const racasParaMarcar = ['Branca', 'Preta', 'Parda'];\n    \n    const option = {\n      title: {\n        text: 'Distribuição por Raça/Cor e Idade (0 a 100 anos)'\n      },\n      tooltip: {\n        trigger: 'axis'\n      },\n      legend: {\n        data: racas,\n        bottom: 10\n      },\n      grid: {\n        left: '3%',\n        right: '4%',\n        bottom: '15%',\n        containLabel: true\n      },\n      toolbox: {\n        feature: {\n          saveAsImage: {}\n        }\n      },\n      xAxis: {\n        type: 'category',\n        boundaryGap: false,\n        data: idades,\n        name: 'Idade'\n      },\n      yAxis: {\n        type: 'value',\n        name: 'Quantidade'\n      },\n      // Configurações de animação\n      animationDuration: 3000,\n      animationEasing: 'cubicOut',\n      series: racas.map(raca =&gt; {\n        const dados = dados_filtrados.map(d =&gt; d[raca]);\n        \n        return {\n          name: raca,\n          type: 'line',\n          data: dados\n        };\n      })\n    };\n    \n    // Renderizar o gráfico inicialmente sem os markPoints\n    myChart.setOption(option);\n    \n    // Adicionar markPoints após a animação terminar\n    setTimeout(() =&gt; {\n      const seriesWithMarkPoints = racas.map(raca =&gt; {\n        const dados = dados_filtrados.map(d =&gt; d[raca]);\n        \n        // Se for uma das raças para marcar, adicionar markPoint\n        let markPoint = {};\n        if (racasParaMarcar.includes(raca)) {\n          const valorMaximo = Math.max(...dados);\n          const indiceMaximo = dados.indexOf(valorMaximo);\n          const idadeMaxima = dados_filtrados[indiceMaximo].idade;\n          \n          markPoint = {\n            data: [{\n              type: 'max',\n              label: {\n                show: true,\n                position: 'top',\n                formatter: `Pico ${raca}: ${idadeMaxima} anos`,\n                backgroundColor: 'rgba(255, 255, 255, 0.9)',\n                borderColor: '#333',\n                borderWidth: 1,\n                borderRadius: 4,\n                padding: [6, 10],\n                fontSize: 12,\n                fontWeight: 'bold'\n              },\n              symbol: 'circle',\n              symbolSize: 8\n            }],\n            animation: true,\n            animationDuration: 800\n          };\n        }\n        \n        return {\n          name: raca,\n          type: 'line',\n          data: dados,\n          markPoint: markPoint\n        };\n      });\n      \n      // Atualizar o gráfico com os markPoints\n      myChart.setOption({\n        series: seriesWithMarkPoints\n      });\n    }, 3100); // Esperar 3100ms (um pouco depois da animação das linhas)\n\n    // Event listener para redimensionamento\n    const resizeHandler = () =&gt; {\n      myChart.resize();\n    };\n    \n    window.addEventListener('resize', resizeHandler);\n    \n    // Cleanup quando a célula for re-executada\n    invalidation.then(() =&gt; {\n      window.removeEventListener('resize', resizeHandler);\n      myChart.dispose();\n    });\n  });\n\n  return chartDom;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndic_raca_cor_ano = FileAttachment(\"./fontes/dic_raca_cor_ano.json\").json()\n\n// Ordenar por ano e garantir numérico\ndados_ordenados = dic_raca_cor_ano\n  .map(d =&gt; ({ ...d, ano: +d.ano }))\n  .filter(d =&gt; !Number.isNaN(d.ano))\n  .sort((a, b) =&gt; d3.ascending(a.ano, b.ano))\n\nchart_ano = {\n  const chartDom = DOM.element('div', { \n    style: `\n      width: 100%; \n      height: 60vw; \n      max-height: 400px; \n      min-height: 300px;\n    ` \n  });\n\n  // Aguarda o DOM estar renderizado usando requestAnimationFrame\n  requestAnimationFrame(() =&gt; {\n    // Inicializa o gráfico após o DOM estar pronto\n    const myChart = echarts.init(chartDom);\n    \n    // Eixo X com anos (ordenados)\n    const anos = dados_ordenados.map(d =&gt; d.ano)\n    \n    // Descobrir as séries (todas as chaves exceto \"ano\")\n    const racas = Object.keys(dados_ordenados[0] || {}).filter(k =&gt; k !== 'ano')\n    \n    // Raças que receberão markPoint no pico\n    const racasParaMarcar = ['Branca', 'Preta', 'Parda']\n    \n    const option = {\n      title: { text: 'Distribuição por Raça/Cor ao longo dos anos' },\n      tooltip: { trigger: 'axis' },\n      legend: { data: racas, bottom: 10 },\n      grid: { left: '3%', right: '4%', bottom: '15%', containLabel: true },\n      toolbox: { feature: { saveAsImage: {} } },\n      xAxis: {\n        type: 'category',\n        boundaryGap: false,\n        data: anos,\n        name: 'Ano'\n      },\n      yAxis: { type: 'value', name: 'Quantidade' },\n      // paleta base (sobrescrevemos por série logo abaixo)\n      color: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'],\n      animationDuration: 3000,\n      animationEasing: 'cubicOut',\n      series: racas.map((raca, index) =&gt; {\n        const dados = dados_ordenados.map(d =&gt; +d[raca] || 0)\n        const coresPorRaca = {\n          Branca:   '#2E86AB',\n          Parda:    '#A23B72',\n          Preta:    '#F18F01',\n          Amarela:  '#C73E1D',\n          Indígena: '#592E83'\n        }\n        const cor = coresPorRaca[raca] || `hsl(${index * 72}, 70%, 50%)`\n        return {\n          name: raca,\n          type: 'line',\n          data: dados,\n          itemStyle: { color: cor },\n          lineStyle: { color: cor }\n        }\n      })\n    }\n    \n    // Render inicial sem markPoints\n    myChart.setOption(option)\n    \n    // Após a animação, adicionar markPoints nos picos das séries escolhidas\n    setTimeout(() =&gt; {\n      const seriesWithMarkPoints = racas.map((raca, index) =&gt; {\n        const dados = dados_ordenados.map(d =&gt; +d[raca] || 0)\n        const coresPorRaca = {\n          Branca:   '#FED789',  // mantive sua paleta custom\n          Parda:    '#72874E',\n          Preta:    '#476F84',\n          Amarela:  '#A4BED5',\n          Indígena: '#453947'\n        }\n        const cor = coresPorRaca[raca] || `hsl(${index * 72}, 70%, 50%)`\n        let markPoint = {}\n        if (racasParaMarcar.includes(raca) && dados.length) {\n          const valorMaximo = Math.max(...dados)\n          const indiceMaximo = dados.indexOf(valorMaximo)\n          const anoPico = anos[indiceMaximo]\n          markPoint = {\n            data: [{\n              type: 'max',\n              name: 'Pico',\n              label: {\n                show: false,\n                position: 'top',\n                formatter: `${raca} - pico: ${anoPico}`,\n                backgroundColor: 'rgba(255, 255, 255, 0.9)',\n                borderColor: cor,\n                borderWidth: 1,\n                borderRadius: 4,\n                padding: [6, 10],\n                fontSize: 12,\n                fontWeight: 'bold'\n              },\n              symbol: 'circle',\n              symbolSize: 8,\n              itemStyle: { color: cor }\n            }],\n            animation: true,\n            animationDuration: 800\n          }\n        }\n        return {\n          name: raca,\n          type: 'line',\n          data: dados,\n          itemStyle: { color: cor },\n          lineStyle: { color: cor },\n          markPoint\n        }\n      })\n      \n      myChart.setOption({ series: seriesWithMarkPoints })\n    }, 3100)\n\n    // Event listener para redimensionamento\n    const resizeHandler = () =&gt; {\n      myChart.resize();\n    };\n    \n    window.addEventListener('resize', resizeHandler);\n    \n    // Cleanup quando a célula for re-executada\n    invalidation.then(() =&gt; {\n      window.removeEventListener('resize', resizeHandler);\n      myChart.dispose();\n    });\n  });\n\n  return chartDom;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLista de DICs\nI20 - Angina pectoris (dor torácica)\nI21 - Infarto agudo do miocárdio - Principal causa de mortalidade no Brasil\nI22 - Infarto do miocárdio recorrente\nI23 - Algumas complicações atuais subseqüentes ao infarto agudo do miocárdio\nI24 - Outras doenças isquêmicas agudas do coração\nI25 - Doença isquêmica crônica do coração"
  },
  {
    "objectID": "dic.html",
    "href": "dic.html",
    "title": "",
    "section": "",
    "text": "echarts = require(\"echarts@5\")\n\n// Ler dados do arquivo JSON (gênero x idade)\ndic_genero_idade = FileAttachment(\"./fontes/dic_genero_idade.json\").json();\n\n// Filtrar dados para idades de 0 a 100\ndados_filtrados_1 = dic_genero_idade.filter(d =&gt; d.idade &gt;= 0 && d.idade &lt;= 100)\n\nchart_dic_genero_idade = {\n  const chartDom = DOM.element('div', { \n    style: `\n      width: 100%; \n      height: 60vw; \n      max-height: 400px; \n      min-height: 300px;\n    ` \n  });\n\n  // Aguarda o DOM estar renderizado usando requestAnimationFrame\n  requestAnimationFrame(() =&gt; {\n    // Inicializa o gráfico após o DOM estar pronto\n    const myChart = echarts.init(chartDom);\n    \n    // Idades no eixo X\n    const idades = dados_filtrados_1.map(d =&gt; d.idade);\n    \n    // Pega as chaves que representam gêneros (tudo exceto 'idade')\n    const generos = Object.keys(dados_filtrados_1[0]).filter(k =&gt; k !== 'idade');\n    \n    // Quais séries marcar com \"pico\" (ajuste se tiver Outros, etc.)\n    const generosParaMarcar = ['Fem', 'Masc'];\n    \n    const option = {\n      title: { text: 'Mortes por Gênero e Idade (0 a 100 anos)',\n  left: 'center',\n  top: 10,\n  backgroundColor: '#72874E40',\n  padding: [8, 16],\n  textStyle: {\n    color: '#000',\n    fontSize: 16,\n    fontWeight: 'bold'\n}},\n      tooltip: { trigger: 'axis' },\n      legend: { data: generos, bottom: 10 },\n      grid: { left: '3%', right: '4%', bottom: '15%', containLabel: true },\n      toolbox: { feature: { saveAsImage: {} } },\n      xAxis: { type: 'category', boundaryGap: false, data: idades, name: 'Idade' },\n      yAxis: { type: 'value', name: 'Quantidade' },\n      animationDuration: 2000,\n      animationEasing: 'cubicOut',\n      series: generos.map(genero =&gt; ({\n        name: genero,\n        type: 'line',\n        data: dados_filtrados_1.map(d =&gt; d[genero] ?? 0)\n      })),\n      graphic: [{\n    type: 'text',\n    // Usar coordenadas relativas ao grid (área do gráfico)\n    left: '20%',\n    top: '30%',\n    style: {\n      text: \"\",\n      fontSize: 20,\n      fill: 'rgba(34, 7, 7, 0.5)',\n      fontWeight: 'bold'\n    }\n  }]\n    };\n    \n    // Renderiza linhas primeiro\n    myChart.setOption(option);\n    \n    // Depois adiciona os markPoints (picos)\n    setTimeout(() =&gt; {\n      const seriesComPicos = generos.map(genero =&gt; {\n        const dadosSerie = dados_filtrados_1.map(d =&gt; d[genero] ?? 0);\n        let markPoint = {};\n        \n        if (generosParaMarcar.includes(genero)) {\n          const valorMax = Math.max(...dadosSerie);\n          const idxMax = dadosSerie.indexOf(valorMax);\n          const idadeMax = dados_filtrados_1[idxMax]?.idade;\n          \n          markPoint = {\n            data: [{\n              type: 'max',\n              label: {\n                show: true,\n                position: 'top',\n                formatter: `Pico ${genero}: ${idadeMax} anos`,\n                backgroundColor: 'rgba(255, 255, 255, 0.9)',\n                borderColor: '#333',\n                borderWidth: 1,\n                borderRadius: 4,\n                padding: [6, 10],\n                fontSize: 12,\n                fontWeight: 'bold'\n              },\n              symbol: 'circle',\n              symbolSize: 8\n            }],\n            animation: true,\n            animationDuration: 800\n          };\n        }\n        \n        return {\n          name: genero,\n          type: 'line',\n          data: dadosSerie,\n          markPoint\n        };\n      });\n      \n      myChart.setOption({ series: seriesComPicos });\n    }, 2100);\n\n    // Event listener para redimensionamento\n    const resizeHandler = () =&gt; {\n      myChart.resize();\n    };\n    \n    window.addEventListener('resize', resizeHandler);\n    \n    // Cleanup quando a célula for re-executada\n    invalidation.then(() =&gt; {\n      window.removeEventListener('resize', resizeHandler);\n      myChart.dispose();\n    });\n  });\n\n  return chartDom;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDestaques: Gênero\nHomens, por diversos motivos morrem mais de DIC (veja ao final a lista de DICs). Considerando dados de 1996 a 2024, homens representam 58.4% do total de mortes.\nTambém morem mais cedo aos 71 anos, comumente 9 anos antes que mulheres.\n\n\n\n\nhtml`&lt;hr style=\"border-top: 5px solid steelblue;\n               box-shadow: 0 2px 4px rgba(0,0,0,0.8);\n               margin: 5rem 0;\"&gt;`\n\n\n\n\n\n\n\ndic_raca_cor_idade = FileAttachment(\"./fontes/dic_raca_cor_idade.json\").json()\n\n// Filtrar dados para idades de 0 a 100\ndados_filtrados = dic_raca_cor_idade.filter(d =&gt; d.idade &gt;= 0 && d.idade &lt;= 100)\n\nchart_raca_cor_idade = {\n  const chartDom = DOM.element('div', { \n    style: `\n      width: 100%; \n      height: 60vw; \n      max-height: 400px; \n      min-height: 300px;\n    ` \n  });\n\n  // Aguarda o DOM estar renderizado usando requestAnimationFrame\n  requestAnimationFrame(() =&gt; {\n    // Inicializa o gráfico após o DOM estar pronto\n    const myChart = echarts.init(chartDom);\n    \n    // Extrair as idades para o eixo X (agora filtradas)\n    const idades = dados_filtrados.map(d =&gt; d.idade);\n    \n    // Extrair as raças/cores (excluindo 'idade')\n    const racas = Object.keys(dados_filtrados[0]).filter(key =&gt; key !== 'idade');\n    \n    // Encontrar os picos para Branca, Preta e Parda\n    const racasParaMarcar = ['Branca', 'Preta', 'Parda'];\n    \n    const option = {\n      title: {\n  text: 'Mortes por Raça/Cor e Idade (0 a 100 anos)',\n  left: 'center',\n  top: 10,\n  backgroundColor: '#72874E40',\n  padding: [8, 16],\n  textStyle: {\n    color: '#000',\n    fontSize: 16,\n    fontWeight: 'bold'\n  }\n},\n      tooltip: {\n        trigger: 'axis'\n      },\n      legend: {\n        data: racas,\n        bottom: 10\n      },\n      grid: {\n        top: 100,\n        left: '3%',\n        right: '4%',\n        bottom: '15%',\n        containLabel: true\n      },\n      toolbox: {\n        feature: {\n          saveAsImage: {}\n        }\n      },\n      xAxis: {\n        type: 'category',\n        boundaryGap: false,\n        data: idades,\n        name: 'Idade'\n      },\n      yAxis: {\n        type: 'value',\n        name: 'Quantidade'\n      },\n      // Configurações de animação\n      animationDuration: 2000,\n      animationEasing: 'cubicOut',\n      series: racas.map(raca =&gt; {\n        const dados = dados_filtrados.map(d =&gt; d[raca]);\n        \n        return {\n          name: raca,\n          type: 'line',\n          data: dados\n        };\n      }),\n       graphic: [{\n    type: 'text',\n    // Usar coordenadas relativas ao grid (área do gráfico)\n    left: '10%',\n    top: '30%',\n    style: {\n      text: \"\",\n      fontSize: 20,\n      fill: 'rgba(34, 7, 7, 0.5)',\n      fontWeight: 'bold'\n    }\n  }]\n    };\n    \n    // Renderizar o gráfico inicialmente sem os markPoints\n    myChart.setOption(option);\n    \n    // Adicionar markPoints após a animação terminar\n    setTimeout(() =&gt; {\n      const seriesWithMarkPoints = racas.map(raca =&gt; {\n        const dados = dados_filtrados.map(d =&gt; d[raca]);\n        \n        // Se for uma das raças para marcar, adicionar markPoint\n        let markPoint = {};\n        if (racasParaMarcar.includes(raca)) {\n          const valorMaximo = Math.max(...dados);\n          const indiceMaximo = dados.indexOf(valorMaximo);\n          const idadeMaxima = dados_filtrados[indiceMaximo].idade;\n          \n          markPoint = {\n            data: [{\n              type: 'max',\n              label: {\n                show: true,\n                position: 'top',\n                formatter: `Pico ${raca}: ${idadeMaxima} anos`,\n                backgroundColor: 'rgba(255, 255, 255, 0.9)',\n                borderColor: '#333',\n                borderWidth: 1,\n                borderRadius: 4,\n                padding: [6, 10],\n                fontSize: 12,\n                fontWeight: 'bold'\n              },\n              symbol: 'circle',\n              symbolSize: 8\n            }],\n            animation: true,\n            animationDuration: 800\n          };\n        }\n        \n        return {\n          name: raca,\n          type: 'line',\n          data: dados,\n          markPoint: markPoint\n        };\n      });\n      \n      // Atualizar o gráfico com os markPoints\n      myChart.setOption({\n        series: seriesWithMarkPoints\n      });\n    }, 2100); // Esperar 2100ms (um pouco depois da animação das linhas)\n\n    // Event listener para redimensionamento\n    const resizeHandler = () =&gt; {\n      myChart.resize();\n    };\n    \n    window.addEventListener('resize', resizeHandler);\n    \n    // Cleanup quando a célula for re-executada\n    invalidation.then(() =&gt; {\n      window.removeEventListener('resize', resizeHandler);\n      myChart.dispose();\n    });\n  });\n\n  return chartDom;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDestaques: Raça/Cor\nPessoas negras (pardas ou pretas) tam maiores chances de morrer antes de pessoas brancas.\nPessoas pardas: maior probabilidade de morte aos 70 anos, 6 antes que pessoas brancas.\nPessoas pretas: maior probabilidade de morte aos 67 anos, 9 antes que pessoas brancas.\n\n\n\n\nhtml`&lt;hr style=\"border-top: 5px solid steelblue;\n               box-shadow: 0 2px 4px rgba(0,0,0,0.8);\n               margin: 5rem 0;\"&gt;`\n\n\n\n\n\n\n\ndic_raca_cor_ano = FileAttachment(\"./fontes/dic_raca_cor_ano.json\").json()\n\n// Ordenar por ano e garantir numérico\ndados_ordenados = dic_raca_cor_ano\n  .map(d =&gt; ({ ...d, ano: +d.ano }))\n  .filter(d =&gt; !Number.isNaN(d.ano))\n  .sort((a, b) =&gt; d3.ascending(a.ano, b.ano))\n\nchart_ano = {\n  const chartDom = DOM.element('div', { \n    style: `\n      width: 100%; \n      height: 60vw; \n      max-height: 400px; \n      min-height: 300px;\n    ` \n  });\n\n  // Aguarda o DOM estar renderizado usando requestAnimationFrame\n  requestAnimationFrame(() =&gt; {\n    // Inicializa o gráfico após o DOM estar pronto\n    const myChart = echarts.init(chartDom);\n    \n    // Eixo X com anos (ordenados)\n    const anos = dados_ordenados.map(d =&gt; d.ano)\n    \n    // Descobrir as séries (todas as chaves exceto \"ano\")\n    const racas = Object.keys(dados_ordenados[0] || {}).filter(k =&gt; k !== 'ano')\n    \n    // Raças que receberão markPoint no pico\n    const racasParaMarcar = ['Branca', 'Preta', 'Parda']\n    \n    const option = {\n       title: { text: 'Mortes por Gênero e Idade (0 a 100 anos)',\n  left: 'center',\n  top: 10,\n  backgroundColor: '#72874E40',\n  padding: [8, 16],\n  textStyle: {\n    color: '#000',\n    fontSize: 16,\n    fontWeight: 'bold'\n}},\n      tooltip: { trigger: 'axis' },\n      legend: { data: racas, bottom: 10 },\n      grid: { left: '3%', right: '4%', bottom: '15%', containLabel: true },\n      toolbox: { feature: { saveAsImage: {} } },\n      xAxis: {\n        type: 'category',\n        boundaryGap: false,\n        data: anos,\n        name: 'Ano'\n      },\n      yAxis: { type: 'value', name: 'Quantidade' },\n      // paleta base (sobrescrevemos por série logo abaixo)\n      color: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'],\n      animationDuration: 2000,\n      animationEasing: 'cubicOut',\n      series: racas.map((raca, index) =&gt; {\n        const dados = dados_ordenados.map(d =&gt; +d[raca] || 0)\n        const coresPorRaca = {\n          Branca:   '#2E86AB',\n          Parda:    '#A23B72',\n          Preta:    '#F18F01',\n          Amarela:  '#C73E1D',\n          Indígena: '#592E83'\n        }\n        const cor = coresPorRaca[raca] || `hsl(${index * 72}, 70%, 50%)`\n        return {\n          name: raca,\n          type: 'line',\n          data: dados,\n          itemStyle: { color: cor },\n          lineStyle: { color: cor }\n        }\n      })\n    }\n    \n    // Render inicial sem markPoints\n    myChart.setOption(option)\n    \n    // Após a animação, adicionar markPoints nos picos das séries escolhidas\n    setTimeout(() =&gt; {\n      const seriesWithMarkPoints = racas.map((raca, index) =&gt; {\n        const dados = dados_ordenados.map(d =&gt; +d[raca] || 0)\n        const coresPorRaca = {\n          Branca:   '#FED789',  // mantive sua paleta custom\n          Parda:    '#72874E',\n          Preta:    '#476F84',\n          Amarela:  '#A4BED5',\n          Indígena: '#453947'\n        }\n        const cor = coresPorRaca[raca] || `hsl(${index * 72}, 70%, 50%)`\n        let markPoint = {}\n        if (racasParaMarcar.includes(raca) && dados.length) {\n          const valorMaximo = Math.max(...dados)\n          const indiceMaximo = dados.indexOf(valorMaximo)\n          const anoPico = anos[indiceMaximo]\n          markPoint = {\n            data: [{\n              type: 'max',\n              name: 'Pico',\n              label: {\n                show: false,\n                position: 'top',\n                formatter: `${raca} - pico: ${anoPico}`,\n                backgroundColor: 'rgba(255, 255, 255, 0.9)',\n                borderColor: cor,\n                borderWidth: 1,\n                borderRadius: 4,\n                padding: [6, 10],\n                fontSize: 12,\n                fontWeight: 'bold'\n              },\n              symbol: 'circle',\n              symbolSize: 8,\n              itemStyle: { color: cor }\n            }],\n            animation: true,\n            animationDuration: 800\n          }\n        }\n        return {\n          name: raca,\n          type: 'line',\n          data: dados,\n          itemStyle: { color: cor },\n          lineStyle: { color: cor },\n          markPoint\n        }\n      })\n      \n      myChart.setOption({ series: seriesWithMarkPoints })\n    }, 2100)\n\n    // Event listener para redimensionamento\n    const resizeHandler = () =&gt; {\n      myChart.resize();\n    };\n    \n    window.addEventListener('resize', resizeHandler);\n    \n    // Cleanup quando a célula for re-executada\n    invalidation.then(() =&gt; {\n      window.removeEventListener('resize', resizeHandler);\n      myChart.dispose();\n    });\n  });\n\n  return chartDom;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLista de DICs\nI20 - Angina pectoris (dor torácica)\nI21 - Infarto agudo do miocárdio - Principal causa de mortalidade no Brasil\nI22 - Infarto do miocárdio recorrente\nI23 - Algumas complicações atuais subseqüentes ao infarto agudo do miocárdio\nI24 - Outras doenças isquêmicas agudas do coração\nI25 - Doença isquêmica crônica do coração\n\n\n\n\nDIC /dic.html Sobre /about.html https://bsky.app/profile/nossasaudeemdados.com.br https://github.com/rolfregehr mailto:rolf@nossasaudeemdados.com.br"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Sobre",
    "section": "",
    "text": "Dados com informações de saúde a partir de dados oficiais.\nCriado e mantido por Rolf Regehr."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Nossa Saúde em Dados",
    "section": "",
    "text": "Doença isquêmica do coração ✅\nCID I20 a I25 \n\n\nPneumonia 🚧\nCID J12 a J18 \n\n\nDiabetes 🚧\nCID E10 a E14\n\n\nHemorragia intracerebral ou oclusão 🚧\nCID I61; I630 a I635; I638; I639; I64 a I66"
  }
]