```{r}
pacman::p_load(tidyverse, jsonlite)
load("./r/dic/sim_dic.rda")
cores <- c(
  '#FED789FF',
  '#023743FF',
  '#72874EFF',
  '#476F84FF',
  '#A4BED5FF',
  '#453947FF'
)


dic_genero_idade <- sim_dic |>
  group_by(idade, genero) |>
  reframe(n = n()) |>
  pivot_wider(names_from = genero, values_from = n, values_fill = 0) |>
  select(-Outro) |>
  write_json('./fontes/dic_genero_idade.json')


dic_raca_cor_idade <- sim_dic |>
  group_by(idade, raca_cor) |>
  reframe(n = n()) |>
  pivot_wider(names_from = raca_cor, values_from = n, values_fill = 0) |>
  select(-SI) |>
  write_json('./fontes/dic_raca_cor_idade.json')



```




```{ojs}
// Célula 1: Importação
d3 = require("d3@7")

// Célula 2: Carregamento dos dados
data = FileAttachment("fontes/dic_genero_idade.json").json()

// Célula 3: Slider de range duplo
viewof ageRange = {
  const form = html`<div style="font-family: sans-serif;">
    <label style="font-weight: bold; margin-bottom: 10px; display: block;">
      Filtro de Idade: <span id="range-display">0 - 100 anos</span>
    </label>
    <div style="position: relative; width: 100%; height: 50px; margin: 20px 0;">
      <!-- Track de fundo -->
      <div style="position: absolute; top: 22px; left: 0; right: 0; height: 6px; background: #ddd; border-radius: 3px;"></div>
      <!-- Track do range selecionado -->
      <div id="range-track" style="position: absolute; top: 22px; height: 6px; background: #007bff; border-radius: 3px;"></div>
      <!-- Slider do mínimo -->
      <input type="range" min="0" max="100" value="0" step="1" id="min-slider"
             style="position: absolute; width: 100%; height: 6px; background: transparent; -webkit-appearance: none; outline: none;">
      <!-- Slider do máximo -->
      <input type="range" min="0" max="100" value="100" step="1" id="max-slider"
             style="position: absolute; width: 100%; height: 6px; background: transparent; -webkit-appearance: none; outline: none;">
    </div>

  </div>`;
  
  const minSlider = form.querySelector('#min-slider');
  const maxSlider = form.querySelector('#max-slider');
  const display = form.querySelector('#range-display');
  const rangeTrack = form.querySelector('#range-track');
  
  // Estilizar os sliders
  const style = html`<style>
    #min-slider, #max-slider {
      pointer-events: none;
    }
    
    #min-slider::-webkit-slider-thumb, #max-slider::-webkit-slider-thumb {
      pointer-events: all;
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    
    #min-slider::-webkit-slider-thumb {
      background: #007bff;
    }
    
    #max-slider::-webkit-slider-thumb {
      background: #28a745;
    }
    
    #min-slider::-moz-range-thumb, #max-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      border: none;
    }
    
    #min-slider::-moz-range-thumb {
      background: #007bff;
    }
    
    #max-slider::-moz-range-thumb {
      background: #28a745;
    }
    
    #min-slider::-webkit-slider-track, #max-slider::-webkit-slider-track {
      background: transparent;
      border: none;
    }
    
    #min-slider::-moz-range-track, #max-slider::-moz-range-track {
      background: transparent;
      border: none;
    }
  </style>`;
  
  document.head.appendChild(style);
  
  let isDragging = false;
  let dragTarget = null;
  
  // Atualizar a visualização do range
  function updateRangeTrack() {
    const min = parseInt(minSlider.value);
    const max = parseInt(maxSlider.value);
    const minPercent = (min / 100) * 100;
    const maxPercent = (max / 100) * 100;
    
    rangeTrack.style.left = minPercent + '%';
    rangeTrack.style.width = (maxPercent - minPercent) + '%';
  }
  
  // Função para atualizar valores
  function updateValues() {
    let min = parseInt(minSlider.value);
    let max = parseInt(maxSlider.value);
    
    // Trocar valores se necessário, mas manter o que está sendo arrastado
    if (min > max) {
      if (dragTarget === minSlider) {
        // Se estou arrastando o mínimo e passou do máximo, 
        // o mínimo vira máximo e vice-versa
        [minSlider.value, maxSlider.value] = [maxSlider.value, minSlider.value];
        [min, max] = [max, min];
      } else if (dragTarget === maxSlider) {
        // Se estou arrastando o máximo e passou do mínimo,
        // o máximo vira mínimo e vice-versa  
        [minSlider.value, maxSlider.value] = [maxSlider.value, minSlider.value];
        [min, max] = [max, min];
      }
    }
    
    display.textContent = `${Math.min(min, max)} - ${Math.max(min, max)} anos`;
    form.value = [Math.min(min, max), Math.max(min, max)];
    form.dispatchEvent(new CustomEvent("input"));
    
    updateRangeTrack();
  }
  
  // Event listeners para detectar início do arraste
  minSlider.addEventListener("mousedown", () => {
    isDragging = true;
    dragTarget = minSlider;
  });
  
  maxSlider.addEventListener("mousedown", () => {
    isDragging = true;
    dragTarget = maxSlider;
  });
  
  // Event listeners para input
  minSlider.addEventListener("input", updateValues);
  maxSlider.addEventListener("input", updateValues);
  
  // Resetar quando soltar
  document.addEventListener("mouseup", () => {
    isDragging = false;
    dragTarget = null;
  });
  
  // Permitir clique na track para mover o slider mais próximo
  rangeTrack.parentElement.addEventListener("click", (e) => {
    if (isDragging) return;
    
    const rect = rangeTrack.parentElement.getBoundingClientRect();
    const clickPercent = (e.clientX - rect.left) / rect.width;
    const clickValue = Math.round(clickPercent * 100);
    
    const minVal = parseInt(minSlider.value);
    const maxVal = parseInt(maxSlider.value);
    
    // Mover o slider mais próximo do clique
    if (Math.abs(clickValue - minVal) < Math.abs(clickValue - maxVal)) {
      minSlider.value = clickValue;
    } else {
      maxSlider.value = clickValue;
    }
    
    updateValues();
  });
  
  // Inicializar
  updateRangeTrack();
  form.value = [0, 100];
  return form;
}

// Célula 4: Extrair valores do range
minAge = ageRange[0]
maxAge = ageRange[1]

// Célula 5: Dados filtrados
filteredData = data.filter(d => d.idade >= minAge && d.idade <= maxAge)

// Célula 6: Estatísticas
md`**Estatísticas do filtro atual:**
- Idade: ${minAge} a ${maxAge} anos
- Total Masculino: ${d3.sum(filteredData, d => d.Masc).toLocaleString()}
- Total Feminino: ${d3.sum(filteredData, d => d.Fem).toLocaleString()}
- Total Geral: ${d3.sum(filteredData, d => d.Masc + d.Fem).toLocaleString()}
- Registros: ${filteredData.length} faixas etárias`

// Célula 7: Gráfico com dados filtrados
Plot.plot({
width: 1400,
  height: 600,
  marginLeft: 60,
  marginBottom: 60,
  style: { fontSize: "18px" }, // aumenta ticks/labels de ambos os eixos
  x: {
    label: "Idade",
    tickSize: 6,
    fontSize: 100    // aumenta números no eixo X
  },
  y: { 
    grid: true,
  },
  color: {scheme: "RdYlBu"},
  marks: [
    Plot.areaY(filteredData, {
      x: "idade",
      y1: "Masc",
      y2: "Fem",
      curve: "step-after",
      fill: (d) => (d["Masc"] < d["Fem"] ? "#FED789FF" : "#72874E80"),
      z: null
    }),
    Plot.lineY(filteredData, {
      x: "idade",
      y: "Fem",
      curve: "step-after",
      stroke: "steelblue",
      strokeWidth: 3
    })
  ]
})
```


```{ojs}
//| echo: false
echarts = require("echarts@5")


// Ler dados do arquivo JSON
dic_raca_cor_idade = FileAttachment("./fontes/dic_raca_cor_idade.json").json()// Filtrar dados para idades de 0 a 100
// Filtrar dados para idades de 0 a 100
dados_filtrados = dic_raca_cor_idade.filter(d => d.idade >= 0 && d.idade <= 100)

chart = {
  const chartDom = DOM.element('div', { style: 'width: 600px; height: 400px;' });
  const myChart = echarts.init(chartDom);
  
  // Extrair as idades para o eixo X (agora filtradas)
  const idades = dados_filtrados.map(d => d.idade);
  
  // Extrair as raças/cores (excluindo 'idade')
  const racas = Object.keys(dados_filtrados[0]).filter(key => key !== 'idade');
  
  // Encontrar os picos para Branca, Preta e Parda
  const racasParaMarcar = ['Branca', 'Preta', 'Parda'];
  
  const option = {
    title: {
      text: 'Distribuição por Raça/Cor e Idade (0 a 100 anos)'
    },
    tooltip: {
      trigger: 'axis'
    },
    legend: {
      data: racas,
      bottom: 10
    },
    grid: {
      left: '3%',
      right: '4%',
      bottom: '15%',
      containLabel: true
    },
    toolbox: {
      feature: {
        saveAsImage: {}
      }
    },
    xAxis: {
      type: 'category',
      boundaryGap: false,
      data: idades,
      name: 'Idade'
    },
    yAxis: {
      type: 'value',
      name: 'Quantidade'
    },
    // Configurações de animação
    animationDuration: 3000,
    animationEasing: 'cubicOut',
    series: racas.map(raca => {
      const dados = dados_filtrados.map(d => d[raca]);
      
      return {
        name: raca,
        type: 'line',
        data: dados
        // Removemos o markPoint daqui
      };
    })
  };
  
  // Renderizar o gráfico inicialmente sem os markPoints
  myChart.setOption(option);
  
  // Adicionar markPoints após a animação terminar
  setTimeout(() => {
    const seriesWithMarkPoints = racas.map(raca => {
      const dados = dados_filtrados.map(d => d[raca]);
      
      // Se for uma das raças para marcar, adicionar markPoint
      let markPoint = {};
      if (racasParaMarcar.includes(raca)) {
        const valorMaximo = Math.max(...dados);
        const indiceMaximo = dados.indexOf(valorMaximo);
        const idadeMaxima = dados_filtrados[indiceMaximo].idade;
        
        markPoint = {
          data: [{
            type: 'max',
            label: {
              show: true,
              position: 'top',
              formatter: `Pico ${raca}: ${idadeMaxima} anos`,
              backgroundColor: 'rgba(255, 255, 255, 0.9)',
              borderColor: '#333',
              borderWidth: 1,
              borderRadius: 4,
              padding: [6, 10],
              fontSize: 12,
              fontWeight: 'bold'
            },
            symbol: 'circle',
            symbolSize: 8
          }],
          animation: true,
          animationDuration: 800
        };
      }
      
      return {
        name: raca,
        type: 'line',
        data: dados,
        markPoint: markPoint
      };
    });
    
    // Atualizar o gráfico com os markPoints
    myChart.setOption({
      series: seriesWithMarkPoints
    });
  }, 3100); // Esperar 3100ms (um pouco depois da animação das linhas)
  
  return chartDom;
}
```


```{ojs}
//| echo: false


// Ler dados do arquivo JSON (cada objeto deve ter a chave "ano" + colunas de raça/cor)
dic_raca_cor_ano = FileAttachment("./fontes/dic_raca_cor_ano.json").json()

// Ordenar por ano e garantir numérico
dados_ordenados = dic_raca_cor_ano
  .map(d => ({ ...d, ano: +d.ano }))
  .filter(d => !Number.isNaN(d.ano))
  .sort((a, b) => d3.ascending(a.ano, b.ano))

chart_ano = {
  const chartDom = DOM.element('div', { style: 'width: 600px; height: 400px;' })
  const myChart = echarts.init(chartDom)

  // Eixo X com anos (ordenados)
  const anos = dados_ordenados.map(d => d.ano)

  // Descobrir as séries (todas as chaves exceto "ano")
  const racas = Object.keys(dados_ordenados[0] || {}).filter(k => k !== 'ano')

  // Raças que receberão markPoint no pico
  const racasParaMarcar = ['Branca', 'Preta', 'Parda']

  const option = {
    title: { text: 'Distribuição por Raça/Cor ao longo dos anos' },
    tooltip: { trigger: 'axis' },
    legend: { data: racas, bottom: 10 },
    grid: { left: '3%', right: '4%', bottom: '15%', containLabel: true },
    toolbox: { feature: { saveAsImage: {} } },
    xAxis: {
      type: 'category',
      boundaryGap: false,
      data: anos,
      name: 'Ano'
    },
    yAxis: { type: 'value', name: 'Quantidade' },
    // paleta base (sobrescrevemos por série logo abaixo)
    color: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'],
    animationDuration: 3000,
    animationEasing: 'cubicOut',
    series: racas.map((raca, index) => {
      const dados = dados_ordenados.map(d => +d[raca] || 0)

      const coresPorRaca = {
        Branca:   '#2E86AB',
        Parda:    '#A23B72',
        Preta:    '#F18F01',
        Amarela:  '#C73E1D',
        Indígena: '#592E83'
      }

      const cor = coresPorRaca[raca] || `hsl(${index * 72}, 70%, 50%)`

      return {
        name: raca,
        type: 'line',
        data: dados,
        itemStyle: { color: cor },
        lineStyle: { color: cor }
      }
    })
  }

  // Render inicial sem markPoints
  myChart.setOption(option)

  // Após a animação, adicionar markPoints nos picos das séries escolhidas
  setTimeout(() => {
    const seriesWithMarkPoints = racas.map((raca, index) => {
      const dados = dados_ordenados.map(d => +d[raca] || 0)

      const coresPorRaca = {
        Branca:   '#FED789',  // mantive sua paleta custom
        Parda:    '#72874E',
        Preta:    '#476F84',
        Amarela:  '#A4BED5',
        Indígena: '#453947'
      }

      const cor = coresPorRaca[raca] || `hsl(${index * 72}, 70%, 50%)`

      let markPoint = {}
      if (racasParaMarcar.includes(raca) && dados.length) {
        const valorMaximo = Math.max(...dados)
        const indiceMaximo = dados.indexOf(valorMaximo)
        const anoPico = anos[indiceMaximo]

        markPoint = {
          data: [{
            type: 'max',
            name: 'Pico',
            label: {
              show: false,
              position: 'top',
              formatter: `${raca} - pico: ${anoPico}`,
              backgroundColor: 'rgba(255, 255, 255, 0.9)',
              borderColor: cor,
              borderWidth: 1,
              borderRadius: 4,
              padding: [6, 10],
              fontSize: 12,
              fontWeight: 'bold'
            },
            symbol: 'circle',
            symbolSize: 8,
            itemStyle: { color: cor }
          }],
          animation: true,
          animationDuration: 800
        }
      }

      return {
        name: raca,
        type: 'line',
        data: dados,
        itemStyle: { color: cor },
        lineStyle: { color: cor },
        markPoint
      }
    })

    myChart.setOption({ series: seriesWithMarkPoints })
  }, 3100)

  return chartDom
}

```



::: {.columns}


::: {.column width="100%"}
::: {.card}
###  Lista de DICs
I20 - Angina pectoris (dor torácica)  
I21 - Infarto agudo do miocárdio - Principal causa de mortalidade no Brasil  
I22 - Infarto do miocárdio recorrente  
I23 - Algumas complicações atuais subseqüentes ao infarto agudo do miocárdio  
I24 - Outras doenças isquêmicas agudas do coração  
I25 - Doença isquêmica crônica do coração  
:::
:::

:::
